# flags.zig

A type-safe command-line argument parser for Zig. Taking inspiration from **Rust clap**, **Python argparse**, and **TigerBeetle's flags** implementation, it lets you define flags using a struct or union(enum) and parses command-line arguments into it.

---

## Table of Contents

- [Overview](#overview)
- [Features](#features)
- [Installation](#installation)
- [Quick Start](#quick-start)
- [Usage Examples](#usage-examples)
- [Advanced Features](#advanced-features)
- [Supported Types](#supported-types)
- [Error Handling](#error-handling)
- [Documentation](#documentation)
- [Credits](#credits)

---

## Overview

**flags.zig** provides a declarative, type-safe approach to command-line parsing by leveraging Zig's powerful comptime capabilities. Define your CLI interface as a struct with defaults and types, and let the library handle the rest.

### Why flags.zig?

- Zero runtime overhead—parsing happens at comptime where possible
- Type safety—catch errors at compile time, not runtime
- Idiomatic Zig—works with the grain of the language
- Zero external dependencies

---

## Features

- [x] Multiple flag types (bool, string, int, float, enum)
- [x] Struct-based argument definition
- [x] Default values via struct fields
- [x] Automatic help generation (`--help`)
- [x] Error handling for invalid/unknown flags
- [x] Positional arguments support
- [x] Subcommands via `union(enum)`
- [x] Short flag names (`-v`)
- [x] Long flag names (`--verbose`)
- [x] Slice support (multiple values per flag)
- [x] Two parsing patterns: repeated, comma-separated

---

## Installation

### 1. Fetch the library

```bash
zig fetch --save git+https://github.com/atisans/flags.zig
```

### 2. Add to your `build.zig`

```zig
const flags = b.dependency("flags", .{});
exe.root_module.addImport("flags", flags.module("flags"));
```

---

## Quick Start

```zig
const std = @import("std");
const flags = @import("flags");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Define flags as a struct with slice support
    const Args = struct {
        name: []const u8 = "world",
        age: u32 = 25,
        active: bool = false,
        
        // Multiple values supported
        files: []const []const u8 = &[_][]const u8{},
        ports: []u16 = &[_]u16{8080},
    };

    // Parse and use
    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    const parsed = try flags.parse(args, Args);

    std.debug.print("Hello {s}! Age: {d}, Active: {}\n", .{
        parsed.name, parsed.age, parsed.active
    });
}
```

---

## Usage Examples

### Basic Flags

```bash
./program --name=alice --age=30 --active
```

### Individual Flag Types

```bash
# String flag
./program --name=bob

# Integer flag
./program --age=40

# Boolean flag (presence = true)
./program --active
```

### Getting Help

```bash
./program --help
```

### Mixed Flags

```bash
./program --name=charlie --age=35 --active
```

### Short Flags

Define single-character flag names for shorter invocations:

```zig
const Args = struct {
    v: bool = false,  // Short flag: -v
    q: bool = false,  // Short flag: -q
};
```

```bash
./program -v -q     # Multiple short flags
./program -v        # Only verbose
```

### Slice (Multiple Values) Support

```zig
const Args = struct {
    files: []const []const u8 = &[_][]const u8{},
    ports: []u16 = &[_]u16{8080},
    tags: []const []const u8 = &[_][]const u8{},
};
```

#### Two Syntax Patterns:

```bash
# Repeated flags (default)
./program --files=a.txt --files=b.txt --files=c.txt

# Comma-separated values  
./program --files=a.txt,b.txt,c.txt
```

---

## Advanced Features

### Type-Safe Arguments

Leverage Zig's type system for compile-time guarantees:

```zig
const Args = struct {
    // u16 enforces valid port range (0-65535)
    port: u16 = 8080,
    
    // Optional types for nullable values
    config: ?[]const u8 = null,
    
    // Enums for valid choices
    format: enum { json, yaml, toml } = .json,
};
```

### Help Documentation

Help is **auto-generated by default** from your struct fields:

```zig
const Args = struct {
    verbose: bool = false,
    port: u16 = 8080,
};

// Running with --help automatically shows:
// Options:
//   --verbose            bool (default: false)
//   --port               u16 (default: 8080)
```

For custom help text, define `pub const help`:

```zig
const Args = struct {
    verbose: bool = false,
    port: u16 = 8080,
    
    pub const help = 
        \\Options:
        \\  --verbose    Enable verbose output (default: false)
        \\  --port       Port to listen on (default: 8080)
    ;
};
```

**Why this approach?**
- Auto-generated by default (zero config)
- Custom help when you want fine-grained control
- Accessible at compile time via `@hasDecl()`
- Type-safe (struct literal validation)
- Zero runtime cost (can be optimized away)

### Subcommands

Git-style subcommands using `union(enum)`:

```zig
const CLI = union(enum) {
    start: struct {
        host: []const u8 = "localhost",
        port: u16 = 8080,
    },
    stop: struct {
        force: bool = false,
    },
    
    pub const help = 
        \\ Server management CLI
        \\ commands:
        \\  start       Start the server
        \\      --host     Hostname to bind to (default: localhost)
        \\      --port     Port to listen on (default: 8080)
        \\  stop        Stop the server
        \\      --force    Force stop (default: false)
    ;
};

const cli = try flags.parse(args, CLI);
switch (cli) {
    .start => |s| startServer(s.host, s.port),
    .stop => |s| stopServer(s.force),
}
```

### Positional Arguments

Use the `@"--"` marker to separate flags from positional arguments:

```zig
const Args = struct {
    verbose: bool = false,
    @"--": void,
    input: []const u8,
    output: []const u8 = "output.txt",
};

// Usage: program --verbose input.txt --output=result.txt
```

---

## Supported Types

| Type | Example | Notes |
|------|---------|-------|
| `bool` | `--verbose` or `--verbose=true/false` | Presence = true |
| Integers | `--port=8080` | `u8`-`u64`, `i8`-`i64` |
| Floats | `--rate=0.5` | `f32`, `f64` |
| Strings | `--name=value` | `[]const u8` only |
| Enums | `--format=json` | Validates against variants |
| Optionals | `--config=path` or omit | `?T` for nullable values |

---

## Error Handling

The parser returns descriptive errors:

```zig
pub const Error = error{
    DuplicateFlag,              // --port=8080 --port=9090
    InvalidArgument,            // No args provided
    InvalidValue,               // --port=not_a_number
    MissingRequiredFlag,        // Required field with no default
    MissingRequiredPositional,  // Positional arg not provided
    MissingSubcommand,          // No subcommand for union
    MissingValue,               // --name (no value after =)
    UnknownFlag,                // --unknown-flag
    UnknownSubcommand,          // prog unknown-cmd
    UnexpectedArgument,         // Extra positional arg
};
```

Example usage:

```zig
const parsed = flags.parse(args, Args) catch |err| {
    std.log.err("Parse error: {s}", .{@errorName(err)});
    return;
};
```

---

## Documentation

See [docs/](docs/) for detailed documentation:

| Document | Description |
|----------|-------------|
| [docs/README.md](docs/README.md) | Usage guide and API reference |
| [docs/DESIGN.md](docs/DESIGN.md) | Architecture and design decisions |

---

## Limitations

- **No short flags** - Use long flags (`--verbose` not `-v`)
- **Equals syntax only** - Use `--name=value` not `--name value`
- **No custom types** - Only built-in types and enums
- **No slices** - Single values only

---

## Credits

This library draws significant inspiration from two exceptional projects:

### TigerBeetle

The design philosophy of struct-based flag definitions and zero-cost abstractions is heavily inspired by [TigerBeetle's flags implementation](https://github.com/tigerbeetle/tigerbeetle). Their approach to type-safe, performant CLI parsing in Zig demonstrates the power of leveraging Zig's comptime capabilities.

### Rust clap

The declarative API design and developer experience patterns are influenced by [Rust's clap crate](https://github.com/clap-rs/clap). Clap's ergonomic structopt-style derive patterns informed our approach to making CLI parsing intuitive while maintaining compile-time safety.

---

<div align="center">

Made with  for the Zig community

</div>
